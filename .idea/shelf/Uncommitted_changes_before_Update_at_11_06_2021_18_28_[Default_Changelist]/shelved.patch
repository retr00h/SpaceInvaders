Index: app/src/main/java/com/devfabiocirelli/spaceinvaders/GameFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.devfabiocirelli.spaceinvaders\r\n\r\nimport android.os.Bundle\r\nimport android.util.Log\r\nimport android.view.LayoutInflater\r\nimport android.view.View\r\nimport android.view.ViewGroup\r\nimport android.widget.Button\r\nimport android.widget.TextView\r\nimport androidx.fragment.app.Fragment\r\nimport kotlinx.android.synthetic.main.fragment_game.*\r\nimport kotlin.concurrent.thread\r\nimport kotlin.random.Random\r\n\r\nclass GameFragment(val mainActivity: MainActivity) : Fragment() {\r\n    val TAG = \"GameFragment\"\r\n\r\n    lateinit var rightButton: Button\r\n    lateinit var leftButton: Button\r\n    lateinit var fireButton: Button\r\n    lateinit var rootView: View\r\n    lateinit var levelText: TextView\r\n    lateinit var livesTextView: TextView\r\n    lateinit var scoreText: TextView\r\n    var fire = false\r\n    var wichLevel = 0\r\n    var numEnemies = 0\r\n    var lives = 0\r\n    var score = 0\r\n    var bloccaThread = false\r\n\r\n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {\r\n\r\n        rootView = inflater.inflate(R.layout.fragment_game, container, false)\r\n        rightButton = rootView.findViewById(R.id.rightButton)\r\n        leftButton = rootView.findViewById(R.id.leftButton)\r\n        fireButton = rootView.findViewById(R.id.fireButton)\r\n        levelText = rootView.findViewById(R.id.levelIntView)\r\n        livesTextView = rootView.findViewById(R.id.livesInt)\r\n        scoreText = rootView.findViewById(R.id.scoreIntView)\r\n\r\n        val gameData = mainActivity.dataBaseHelper.readGameData()\r\n\r\n        wichLevel = gameData.level\r\n        numEnemies = gameData.enemies\r\n        lives = gameData.lives\r\n        score = gameData.score\r\n\r\n        levelText.setText(\"${mainActivity.applicationContext.getString(R.string.LevelText)}: ${wichLevel}\")\r\n        livesTextView.setText(\"${mainActivity.applicationContext.getString(R.string.livesText)}: ${lives}\")\r\n        scoreText.setText(\"${mainActivity.applicationContext.getString(R.string.scoreText)}: ${score}\")\r\n\r\n        rightButton.setOnClickListener{\r\n            gameField.onClickUpdateRight()\r\n        }\r\n\r\n        leftButton.setOnClickListener{\r\n            gameField.onClickUpdateLeft()\r\n        }\r\n\r\n        fireButton.setOnClickListener{\r\n            gameField.onClickAddBullet()\r\n            fire = true\r\n            gameField.onClickFire()\r\n\r\n        }\r\n\r\n        thread(start = true) {\r\n            var timing = 0\r\n            val random = Random\r\n            while (true) {\r\n                //Se il giocatore ha sparato, entra nell'if e chiede alla view di ridisegnarsi ogni 100 millisecondi\r\n                    try {\r\n                        if(bloccaThread){\r\n                            break\r\n                        }\r\n                        if (fire) {\r\n                            //if (timing % 2 == 0) {\r\n                                var fine = gameField.onClickFire()\r\n                                gameField.invalidate()\r\n                                if (fine == 0) {\r\n                                    fire = false\r\n                                }\r\n                            //timing = 0\r\n                            //}\r\n                        }\r\n                        timing++\r\n                        /*\r\n                        la variabile timing serve per dare \"velocita'\" diverse agli elementi presenti sul canvas,\r\n                        timing % 2 == 0 ridisegna i nemici ogni due cicli (mentre i proiettili vengono ridisegnati ad ogni ciclo)\r\n                         */\r\n                        if (timing % 2 == 0) {\r\n                            if (gameField.start) {\r\n                                gameField.enemyUpdatePosition()\r\n                            }\r\n                            timing = 0\r\n                        }\r\n\r\n                        if(gameField.colpito) {\r\n                            gameField.colpito = false\r\n                            score += gameField.points\r\n                            setNewScore(score)\r\n                        }\r\n\r\n                        if(gameField.start){\r\n                            gameField.enemyFire(random.nextInt(0, gameField.numEnemy))\r\n                        }\r\n\r\n                        Thread.sleep(100)\r\n\r\n                        if(gameField.getEnemy() <= 0){\r\n                            score += gameField.points\r\n                            setNewScore(score)\r\n                            mainActivity.scoreFragment()\r\n                            setEnemies(numEnemies)\r\n                            break\r\n                        }\r\n\r\n                    } catch (e :NullPointerException) {\r\n                        break\r\n                    }\r\n\r\n\r\n            }\r\n        }\r\n\r\n\r\n        return rootView\r\n\r\n\r\n\r\n    }\r\n\r\n    override fun onStart() {\r\n        super.onStart()\r\n        setEnemies(numEnemies)\r\n    }\r\n\r\n    override fun onPause() {\r\n        super.onPause()\r\n        bloccaThread = true\r\n        mainActivity.dataBaseHelper.updateGameData(score, lives, gameField.getEnemy(), wichLevel, 1)\r\n\r\n    }\r\n\r\n    override fun onResume() {\r\n        super.onResume()\r\n        bloccaThread = false\r\n\r\n    }\r\n\r\n    private fun setEnemies(enemies: Int){\r\n        gameField.generateEnemy(enemies)\r\n    }\r\n\r\n    private fun setNewScore(newScore: Int){\r\n        scoreText.post {\r\n            scoreText.setText(\"${mainActivity.applicationContext.getString(R.string.scoreText)}: ${newScore}\")\r\n        }\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/devfabiocirelli/spaceinvaders/GameFragment.kt	(revision 2f524b9515e5e8c4d5218afab147919fd7629663)
+++ app/src/main/java/com/devfabiocirelli/spaceinvaders/GameFragment.kt	(date 1623428913171)
@@ -28,6 +28,9 @@
     var lives = 0
     var score = 0
     var bloccaThread = false
+    var alreadyClicked = false
+    var fireCicle = 9
+    var enemySpeed = 2
 
     override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
 
@@ -59,9 +62,12 @@
         }
 
         fireButton.setOnClickListener{
-            gameField.onClickAddBullet()
-            fire = true
-            gameField.onClickFire()
+              if(!alreadyClicked) {
+                  alreadyClicked = true
+                  gameField.onClickAddBullet()
+                  fire = true
+                  gameField.onClickFire()
+              }
 
         }
 
@@ -71,6 +77,16 @@
             while (true) {
                 //Se il giocatore ha sparato, entra nell'if e chiede alla view di ridisegnarsi ogni 100 millisecondi
                     try {
+                        if(gameField.giocatoreColpito){
+                            lives = gameField.playerLives
+                            gameField.giocatoreColpito = false
+                            setNewPlayerLives(lives)
+                            if(gameField.playerLives <= 0){
+                            mainActivity.gameOverFragment()
+                            break
+                            }
+                        }
+                        //termina il thread se bloccaThread == ture
                         if(bloccaThread){
                             break
                         }
@@ -86,18 +102,27 @@
                         }
                         timing++
                         /*
+                        Il seguente if setta un cooldown in modo che il giocatore possa sparare un proiettile
+                        ogni 0,9 secondi (dopo che ha premuto il tasto per sparare, deve atendere 9 cicli del thread
+                        prima di poter sparare nuovamente)
+                         */
+                        if(timing % fireCicle == 0 || timing >= 10){
+                            alreadyClicked = false
+                            timing = 0
+                        }
+                        /*
                         la variabile timing serve per dare "velocita'" diverse agli elementi presenti sul canvas,
                         timing % 2 == 0 ridisegna i nemici ogni due cicli (mentre i proiettili vengono ridisegnati ad ogni ciclo)
                          */
-                        if (timing % 2 == 0) {
+                        if (timing % enemySpeed == 0) {
                             if (gameField.start) {
                                 gameField.enemyUpdatePosition()
                             }
-                            timing = 0
+
                         }
 
-                        if(gameField.colpito) {
-                            gameField.colpito = false
+                        if(gameField.nemicoColpito) {
+                            gameField.nemicoColpito = false
                             score += gameField.points
                             setNewScore(score)
                         }
@@ -159,4 +184,11 @@
         }
     }
 
+    private fun setNewPlayerLives(remainingLives: Int){
+        livesTextView.post{
+            livesTextView.setText("${mainActivity.applicationContext.getString(R.string.livesText)}: ${remainingLives}")
+            mainActivity.dataBaseHelper.updateGameData(score, lives, gameField.getEnemy(), wichLevel, 1)
+        }
+    }
+
 }
\ No newline at end of file
Index: app/src/main/java/com/devfabiocirelli/spaceinvaders/MainActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.devfabiocirelli.spaceinvaders\r\n\r\nimport android.graphics.drawable.AnimationDrawable\r\nimport android.os.Bundle\r\nimport android.util.DisplayMetrics\r\nimport android.view.View\r\nimport android.widget.FrameLayout\r\nimport androidx.appcompat.app.AppCompatActivity\r\nimport androidx.fragment.app.FragmentTransaction\r\nimport java.util.*\r\n\r\n/**\r\n * Questa classe è responsabile dell'avvio dell'applicazione:\r\n * - istanzia i fragment;\r\n * - gestisce l'animazione dello sfondo;\r\n * - contiene informazioni come impostazioni e dati di gioco, e li aggiorna a livello di\r\n *   database quando richiesto.\r\n */\r\nclass MainActivity : AppCompatActivity() {\r\n    val startPageFragment = StartPageFragment(this)\r\n    val settingsFragment = SettingsFragment(this)\r\n    lateinit var gameFragment: GameFragment\r\n\r\n    private lateinit var backgroundAnimation: AnimationDrawable\r\n    lateinit var gameData: GameData\r\n    lateinit var settings: Settings\r\n    val dataBaseHelper = DataBaseHelper(this)\r\n\r\n    /**\r\n     * In questo metodo viene recuperata l'animazione dello sfondo\r\n     * (usata poi in onStart() e onStop()), vengono letti impostazioni e dati di gioco dal db,\r\n     * e posti in delle variabili, e viene applicata la localizzazione (lingua)\r\n     */\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        setContentView(R.layout.activity_main)\r\n        // inizializza la variabile backgroundAnimation, usata in onStart() e onStop()\r\n        // per far partire/fermare l'animazione dello sfondo\r\n        findViewById<FrameLayout>(R.id.contentFragment).apply {\r\n            backgroundAnimation = background as AnimationDrawable\r\n        }\r\n\r\n        // legge impostazioni e dati di gioco dal database, e applica la lingua\r\n        settings = dataBaseHelper.readSettings()\r\n        gameData = dataBaseHelper.readGameData()\r\n        val dm: DisplayMetrics = resources.displayMetrics\r\n        val conf = resources.configuration\r\n        conf.locale = if (settings.locale.startsWith(\"en\")) Locale.ENGLISH else Locale.ITALIAN\r\n        resources.updateConfiguration(conf, dm)\r\n\r\n        gameFragment = GameFragment(this)\r\n\r\n        // inserisce l'istanza di startPageFragment nel contentFragment e la visualizza\r\n        val fragmentManager = supportFragmentManager\r\n        val transaction: FragmentTransaction = fragmentManager.beginTransaction()\r\n        transaction.replace(R.id.contentFragment, startPageFragment)\r\n        transaction.commit()\r\n    }\r\n\r\n    override fun onStart() {\r\n        super.onStart()\r\n        // fa partire l'animazione del background\r\n        backgroundAnimation.start()\r\n    }\r\n\r\n    override fun onStop() {\r\n        super.onStop()\r\n        // ferma l'animazione del background\r\n        backgroundAnimation.stop()\r\n    }\r\n\r\n    /**\r\n     * Quando la main activity ottiene il focus, questo metodo nasconde\r\n     * la barra delle notifiche e la barra di navigazione\r\n     */\r\n    override fun onWindowFocusChanged(hasFocus: Boolean) {\r\n        super.onWindowFocusChanged(hasFocus)\r\n        if (hasFocus) hideSystemUI()\r\n    }\r\n\r\n    private fun hideSystemUI() {\r\n        // Enables regular immersive mode.\r\n        // For \"lean back\" mode, remove SYSTEM_UI_FLAG_IMMERSIVE.\r\n        // Or for \"sticky immersive,\" replace it with SYSTEM_UI_FLAG_IMMERSIVE_STICKY\r\n        window.decorView.systemUiVisibility = (View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY\r\n                // Set the content to appear under the system bars so that the\r\n                // content doesn't resize when the system bars hide and show.\r\n                or View.SYSTEM_UI_FLAG_LAYOUT_STABLE\r\n                or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION\r\n                or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\r\n                // Hide the nav bar and status bar\r\n                or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION\r\n                or View.SYSTEM_UI_FLAG_FULLSCREEN)\r\n    }\r\n\r\n    fun scoreFragment(){\r\n        val nextLevelFragment = ScoreFragment(this)\r\n        val fragmentManager = supportFragmentManager\r\n        val transaction: FragmentTransaction = fragmentManager.beginTransaction()\r\n        transaction.replace(R.id.contentFragment, nextLevelFragment)\r\n        transaction.commit()\r\n    }\r\n\r\n    fun gameFragment(){\r\n        gameFragment = GameFragment(this)\r\n        val fragmentManager = supportFragmentManager\r\n        val transaction: FragmentTransaction = fragmentManager.beginTransaction()\r\n        transaction.replace(R.id.contentFragment, gameFragment)\r\n        transaction.commit()\r\n    }\r\n\r\n    fun startPageFragment(){\r\n        val fragmentManager = supportFragmentManager\r\n        val transaction: FragmentTransaction = fragmentManager.beginTransaction()\r\n        transaction.replace(R.id.contentFragment, startPageFragment)\r\n        transaction.commit()\r\n    }\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/devfabiocirelli/spaceinvaders/MainActivity.kt	(revision 2f524b9515e5e8c4d5218afab147919fd7629663)
+++ app/src/main/java/com/devfabiocirelli/spaceinvaders/MainActivity.kt	(date 1623428810244)
@@ -20,6 +20,7 @@
     val startPageFragment = StartPageFragment(this)
     val settingsFragment = SettingsFragment(this)
     lateinit var gameFragment: GameFragment
+    lateinit var gameOverFragment: gameOverFragment
 
     private lateinit var backgroundAnimation: AnimationDrawable
     lateinit var gameData: GameData
@@ -115,6 +116,14 @@
         transaction.replace(R.id.contentFragment, startPageFragment)
         transaction.commit()
     }
+
+    fun gameOverFragment(){
+        gameOverFragment = gameOverFragment(this)
+        val fragmentManager = supportFragmentManager
+        val transaction: FragmentTransaction = fragmentManager.beginTransaction()
+        transaction.replace(R.id.contentFragment, gameOverFragment)
+        transaction.commit()
+    }
 
 
 }
\ No newline at end of file
Index: app/src/main/java/com/devfabiocirelli/spaceinvaders/Field.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.devfabiocirelli.spaceinvaders\r\n\r\nimport android.content.Context\r\nimport android.graphics.*\r\nimport android.util.AttributeSet\r\nimport android.util.Log\r\nimport android.view.View\r\nimport kotlin.random.Random\r\n\r\nclass Field: View {\r\n\r\n    private val paint = Paint()\r\n    val TAG = \"activity\"\r\n    lateinit var canvas: Canvas\r\n    //la variabile fire serve per far sapere al canvas se disegnare  o meno i proiettili sparati dal giocatore\r\n    var fire: Boolean = false\r\n    //istanza della classe Player, classe dedicata al giocatore\r\n    var playerShip: Player? = null\r\n    //istanza della classe Enemy dedicata ai nemici\r\n    var enemy: Enemy? = null\r\n    //la variabile start indica se il gioco sia portito o meno al thread lanciato dal GameFragment\r\n    var start = false\r\n    var numEnemy = 0\r\n    var points = 0\r\n    //colpito serve al thread lanciato da GameFragment in modo che se il giocatore\r\n    //colpisce un nemico, il thread lo sappia e aggiorni il punteggio del giocatore\r\n    var colpito = false\r\n    //generatore di numeri random\r\n    val random = Random\r\n\r\n    constructor(context: Context?) : super(context){\r\n        init(null)\r\n    }\r\n\r\n    constructor(context: Context?, attrs: AttributeSet?) : super(context, attrs){\r\n        init(attrs)\r\n    }\r\n\r\n    constructor(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr){\r\n        init(attrs)\r\n    }\r\n\r\n    private fun init(attrs: AttributeSet?){\r\n\r\n        setOnClickListener{\r\n            invalidate()\r\n        }\r\n\r\n    }\r\n\r\n    override fun onDraw(canvas: Canvas) {\r\n        super.onDraw(canvas)\r\n\r\n        this.canvas = canvas\r\n\r\n        if(playerShip == null) {\r\n            playerShip = Player(context, width, height)\r\n        }\r\n\r\n        var i = 0\r\n\r\n        if(enemy == null){\r\n            enemy = Enemy(context, width, height)\r\n            enemy!!.addEnemy(numEnemy)\r\n\r\n        }\r\n\r\n        //disegna tutti i nemici presenti in enemyList\r\n        for(e: Bitmap in enemy!!.enemyList){\r\n            paint.setColor(Color.RED)\r\n            canvas.drawRect(enemy!!.enemyHitboxList[i], paint)\r\n            paint.setColor(Color.BLACK)\r\n            canvas.drawBitmap(e, (enemy!!.enemyHitboxList[i].left).toFloat(), (height/100).toFloat(), paint)\r\n            i++\r\n            invalidate()\r\n        }\r\n        //se ci sono proiettili sparati dai nemici, vengono disegnati sul canvas\r\n        if(enemy!!.bulletList.size > 0) {\r\n            for (bullet: Rect in enemy!!.bulletList) {\r\n                paint.setColor(Color.RED)\r\n                canvas.drawRect(bullet, paint)\r\n            }\r\n        }\r\n\r\n        //setta start a true dopo aver disegnato i nemici per animarli nel gameFragment\r\n        start = true\r\n\r\n        //Disegna il giocatore e la sua hitbox\r\n        paint.setColor(Color.TRANSPARENT)\r\n        canvas.drawRect(playerShip!!.playerHitBox, paint)\r\n        paint.setColor(Color.BLACK)\r\n        canvas.drawBitmap(playerShip!!.mShipBitmap, (playerShip!!.x).toFloat(), (playerShip!!.y).toFloat(), paint)\r\n\r\n        /*\r\n        al primo ciclo dell'onDraw la variabile fire è settata a false, al click del bottone per sparare viene settata a true\r\n        quindi viene invalidato il canvas e quindi ridisegnato, a questo punto può entrare nell'if e disegnare il proiettile sparato\r\n        questo ciclo viene iterato finchè il proiettile o entra in collisione con un personaggio, o arriva alla fine dello schermo\r\n         */\r\n        if(fire) {\r\n            paint.setColor(playerShip!!.bulletColor)\r\n            for(bullet: Rect in playerShip!!.bulletList) {\r\n                var pos = 0\r\n                for (enemyHitbox: Rect in enemy!!.enemyHitboxList) {\r\n                    if (bullet.intersect(enemyHitbox)) {\r\n                        points = 50\r\n                        colpito = true\r\n                        playerShip!!.compactBulletList(bullet)\r\n                        enemy!!.compactEnemyList(enemyHitbox, pos)\r\n                    } else {\r\n                        canvas.drawRect(bullet, paint)\r\n                    }\r\n                    canvas.drawRect(bullet, paint)\r\n                    pos++\r\n                }\r\n            }\r\n                }\r\n\r\n            }\r\n\r\n    //genera il numero di nemici indicato da n\r\n    fun generateEnemy(n: Int){\r\n        numEnemy = n\r\n    }\r\n\r\n    /*\r\n    metodi di gestione del movimento del giocatore,\r\n    invocano dei metodi della classe Player\r\n     */\r\n    fun onClickUpdateRight(){\r\n        playerShip?.updatePlayerPosition(1)\r\n        invalidate()\r\n    }\r\n\r\n    fun onClickUpdateLeft(){\r\n        playerShip?.updatePlayerPosition(0)\r\n        invalidate()\r\n    }\r\n\r\n    var p = 2\r\n\r\n    fun onClickFire(): Int{\r\n        /*se p è maggiore di zero vuol dire che ci sono dei proiettili nella lista dei proiettili sparati dal giocatore\r\n        e quindi dovranno essere diegnati sul canvas\r\n         */\r\n        if (p > 0) {\r\n            fire = true\r\n            p = playerShip!!.fire()\r\n            return 1\r\n        } else {\r\n            fire = false\r\n            p = 2\r\n            invalidate()\r\n            return 0\r\n        }\r\n    }\r\n\r\n    //aggiunge un proiettile ogni voltache l'utente preme sul bottone per sparare\r\n    fun onClickAddBullet(){\r\n        playerShip!!.addBullet()\r\n    }\r\n\r\n\r\n    //all'avvio del gioco i nemici si spostano verso destra\r\n    var enemyPos = 1\r\n    var direction = 1\r\n\r\n    fun enemyUpdatePosition(){\r\n            direction = enemy!!.updatePosition(enemyPos)\r\n            if (direction >= width) {\r\n                enemyPos = 0\r\n            }\r\n            if (direction <= 0) {\r\n                if(enemy!!.noEnemy){\r\n                    start = false\r\n                } else {\r\n                    enemyPos = 1\r\n                }\r\n            }\r\n    }\r\n\r\n    fun getEnemy(): Int{\r\n        return enemy!!.getNumEnemy()\r\n    }\r\n\r\n    //genero un Random per fare in modo che un nemico decida casualmente di sparare\r\n    fun enemyFire(i: Int){\r\n        if(random.nextInt(50) == 5){\r\n            enemy!!.addBullet(i)\r\n        }\r\n        enemy!!.fire()\r\n\r\n    }\r\n}\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/devfabiocirelli/spaceinvaders/Field.kt	(revision 2f524b9515e5e8c4d5218afab147919fd7629663)
+++ app/src/main/java/com/devfabiocirelli/spaceinvaders/Field.kt	(date 1623428913176)
@@ -24,9 +24,11 @@
     var points = 0
     //colpito serve al thread lanciato da GameFragment in modo che se il giocatore
     //colpisce un nemico, il thread lo sappia e aggiorni il punteggio del giocatore
-    var colpito = false
+    var nemicoColpito = false
     //generatore di numeri random
     val random = Random
+    var playerLives = 0
+    var giocatoreColpito = false
 
     constructor(context: Context?) : super(context){
         init(null)
@@ -74,13 +76,6 @@
             i++
             invalidate()
         }
-        //se ci sono proiettili sparati dai nemici, vengono disegnati sul canvas
-        if(enemy!!.bulletList.size > 0) {
-            for (bullet: Rect in enemy!!.bulletList) {
-                paint.setColor(Color.RED)
-                canvas.drawRect(bullet, paint)
-            }
-        }
 
         //setta start a true dopo aver disegnato i nemici per animarli nel gameFragment
         start = true
@@ -91,6 +86,20 @@
         paint.setColor(Color.BLACK)
         canvas.drawBitmap(playerShip!!.mShipBitmap, (playerShip!!.x).toFloat(), (playerShip!!.y).toFloat(), paint)
 
+        //se ci sono proiettili sparati dai nemici, vengono disegnati sul canvas
+        if(enemy!!.bulletList.size > 0) {
+            paint.setColor(Color.RED)
+            for (bullet: Rect in enemy!!.bulletList) {
+                if(bullet.intersect(playerShip!!.playerHitBox)){
+                    Log.i("CIAOOOOOOO", "Giocatore colpito")
+                    giocatoreColpito = true
+                    playerLives -= 1
+                } else {
+                    canvas.drawRect(bullet, paint)
+                }
+            }
+        }
+
         /*
         al primo ciclo dell'onDraw la variabile fire è settata a false, al click del bottone per sparare viene settata a true
         quindi viene invalidato il canvas e quindi ridisegnato, a questo punto può entrare nell'if e disegnare il proiettile sparato
@@ -103,7 +112,7 @@
                 for (enemyHitbox: Rect in enemy!!.enemyHitboxList) {
                     if (bullet.intersect(enemyHitbox)) {
                         points = 50
-                        colpito = true
+                        nemicoColpito = true
                         playerShip!!.compactBulletList(bullet)
                         enemy!!.compactEnemyList(enemyHitbox, pos)
                     } else {
@@ -189,6 +198,10 @@
         }
         enemy!!.fire()
 
+    }
+
+    fun playerLives(){
+
     }
 }
 
Index: app/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<resources>\r\n    <string name=\"app_name\" translatable=\"false\">\"Space Invaders\"</string>\r\n    <string name=\"haptic_switch_text\">Vibrations</string>\r\n    <string name=\"audio_switch_text\">Sound</string>\r\n    <string name=\"language_name\">English</string>\r\n    <string name=\"language_text\">Language</string>\r\n    <string name=\"startButton\">Start</string>\r\n    <string name=\"gameTitle\" translatable=\"false\">Space Invaders</string>\r\n    <string name=\"language_will_be_applied\">Language preference updated, they will be applied by changing window.</string>\r\n    <!-- TODO: Remove or change this placeholder text -->\r\n    <string name=\"resume_game\">Resume game</string>\r\n    <string name=\"customButton\">Ship customization</string>\r\n    <string name=\"alertTitle\">Alert!</string>\r\n    <string name=\"alertMessage\">Starting a new game will delete the saved one. Continue?</string>\r\n    <string name=\"alertPositiveButton\">Yes</string>\r\n    <string name=\"alertNegativeButton\">No</string>\r\n    <string name=\"noSavedGameAvailable\">There isn\\'t any game to resume</string>\r\n    <string name=\"login_first\">You have to login with Google first!</string>\r\n    <string name=\"dbCustomUpdateError\">Error, could\\'t save selected customizations</string>\r\n    <string name=\"dbCustomUpdateOk\">Customizations updated!</string>\r\n    <string name=\"currentSelectedCustomization\">Current customizations selected</string>\r\n    <string name=\"SpaceshipModel\">Spaceship:</string>\r\n    <string name=\"selectedColor\">Bullet color:</string>\r\n    <string name=\"Fire\">Fire</string>\r\n    <string name=\"LevelText\">\"Level \"</string>\r\n    <string name=\"livesText\">\"Lives \"</string>\r\n    <string name=\"scoreText\">\"Score \"</string>\r\n    <!-- TODO: Remove or change this placeholder text -->\r\n    <string name=\"CompletedText\">Completed!</string>\r\n    <string name=\"nextLevelTextButton\">Next level</string>\r\n    <string name=\"gameCompleted\">Game completed!</string>\r\n    <string name=\"HomePage\">Home page</string>\r\n</resources>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/res/values/strings.xml	(revision 2f524b9515e5e8c4d5218afab147919fd7629663)
+++ app/src/main/res/values/strings.xml	(date 1623427947070)
@@ -31,4 +31,6 @@
     <string name="nextLevelTextButton">Next level</string>
     <string name="gameCompleted">Game completed!</string>
     <string name="HomePage">Home page</string>
+    <!-- TODO: Remove or change this placeholder text -->
+    <string name="hello_blank_fragment">Hello blank fragment</string>
 </resources>
\ No newline at end of file
